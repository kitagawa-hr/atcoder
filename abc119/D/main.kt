import java.io.BufferedInputStream
import java.io.InputStream
import java.io.PrintWriter
import java.util.StringTokenizer

val pw = PrintWriter(System.out)
const val INF = 10000000000000L

fun solve(A: Long, B: Long, Q: Long, s: LongArray, t: LongArray, x: LongArray) {
    // ll lr rl rr
    fun leftDist(pos: Long, list: List<Long>): Long{
        val ret = list.binarySearch(pos)
        if ( ret > 0 ) return 0L
        val insertionPos = -ret - 1
        return when(insertionPos){
            0 -> INF
            else -> pos - list[insertionPos - 1]
        }
    }
    fun rightDist(pos: Long, list: List<Long>): Long{
        val ret = list.binarySearch(pos)
        if ( ret > 0 ) return 0L
        val insertionPos = -ret - 1
        return when(insertionPos){
            list.size -> INF
            else -> list[insertionPos] - pos
        }
    }
    val S = s.toList()
    val T = t.toList()
    repeat(Q.toInt()) {
        val lS = leftDist(x[it], S)
        val rS = rightDist(x[it], S)
        val lT = leftDist(x[it], T)
        val rT = rightDist(x[it], T)
        val ans = listOf(
            Math.max(lS, lT),
            Math.max(rS, rT),
            2*lS + rT,
            2*lT + rS,
            lS + 2*rT,
            lT + 2*rS).min()!!
        pw.println(ans)
    }
    pw.flush()
    return
}


fun <T : Comparable<T>> List<T?>.lowerBound(
        element: T,
        fromIndex: Int = 0,
        toIndex: Int = size
): Int {
    var low = fromIndex
    var high = toIndex
    while (low < high) {
        val mid = (low + high) / 2
        if (element <= this.get(mid)!!) {
            high = mid
        } else {
            low = mid + 1
        }
    }
    return low
}

fun <T : Comparable<T>> List<T?>.upperBound(
        element: T,
        fromIndex: Int = 0,
        toIndex: Int = size
): Int {
    var low = fromIndex
    var high = toIndex
    while (low < high) {
        val mid = (low + high) / 2
        if (element >= this.get(mid)!!) {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return low
}

// Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
fun main(args: Array<String>) {
    fun StringArray(size: Int, init: (Int) -> String = { "\u0000" }): Array<String> {
        return Array<String>(size, init)
    }
    class Scanner(stream: InputStream) {
        private val reader = BufferedInputStream(stream).bufferedReader()
        private var st: StringTokenizer? = null
        fun next(): String {
            while (!(st?.hasMoreTokens() ?: false)) st = StringTokenizer(reader.readLine())
            return st!!.nextToken()
        }
    }
    val sc = Scanner(System.`in`)
    val A = sc.next().toLong()
    val B = sc.next().toLong()
    val Q = sc.next().toLong()
    val s = LongArray(A.toInt())
    for (i in 0 until A.toInt()) {
        s[i] = sc.next().toLong()
    }
    val t = LongArray(B.toInt())
    for (i in 0 until B.toInt()) {
        t[i] = sc.next().toLong()
    }
    val x = LongArray(Q.toInt())
    for (i in 0 until Q.toInt()) {
        x[i] = sc.next().toLong()
    }
    solve(A, B, Q, s, t, x)
}
