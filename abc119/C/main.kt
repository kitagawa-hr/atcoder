import java.io.BufferedInputStream
import java.io.InputStream
import java.util.StringTokenizer

fun solve(N: Int, A: Int, B: Int, C: Int, l: IntArray) {
    fun calcScore(a: Int, b: Int, c: Int) =
        listOf(A - a, B - b, C - c).sumBy { Math.abs(it) }
    // 0: no use, 1: A, 2: B, 3: C
    val pattern = listOf(0, 1, 2, 3)
    val choices = product(*Array(N) { pattern })
    var ans = 10000000
    for (choice in choices) {
        val aa = choice.mapIndexed { index, value -> if (value == 1) l[index] else 0 }
        val bb = choice.mapIndexed { index, value -> if (value == 2) l[index] else 0 }
        val cc = choice.mapIndexed { index, value -> if (value == 3) l[index] else 0 }
        val asize = aa.count { it != 0 }
        val bsize = bb.count { it != 0 }
        val csize = cc.count { it != 0 }
        if (asize < 1 || bsize < 1 || csize < 1) continue
        ans = Math.min(
            ans,
            calcScore(aa.sum(), bb.sum(), cc.sum()) + (asize + bsize + csize - 3) * 10
        )
    }
    println(ans)
    return
}

fun <T> product(vararg lists: List<T>): List<List<T>> {
    fun <T> oneDimTimesOne(left: List<T>, right: List<T>): List<List<T>> =
            left.flatMap { lelem -> right.map { relem -> listOf(lelem, relem) } }

    fun <T> twoDimTimesOne(left: List<List<T>>, right: List<T>): List<List<T>> {
        val product = mutableListOf<List<T>>()
        for (list in left) {
            for (element in right) {
                product.add(list + listOf(element))
            }
        }
        return product
    }
    require(lists.size >= 2)
    return lists
            .drop(2)
            .fold(oneDimTimesOne(lists[0], lists[1])) { acc, suc -> twoDimTimesOne(acc, suc) }
}
// Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
fun main(args: Array<String>) {
    fun StringArray(size: Int, init: (Int) -> String = { "\u0000" }): Array<String> {
        return Array<String>(size, init)
    }
    class Scanner(stream: InputStream) {
        private val reader = BufferedInputStream(stream).bufferedReader()
        private var st: StringTokenizer? = null
        fun next(): String {
            while (!(st?.hasMoreTokens() ?: false)) st = StringTokenizer(reader.readLine())
            return st!!.nextToken()
        }
    }
    val sc = Scanner(System.`in`)
    val N = sc.next().toInt()
    val A = sc.next().toInt()
    val B = sc.next().toInt()
    val C = sc.next().toInt()
    val l = IntArray(N)
    for (i in 0 until N) {
        l[i] = sc.next().toInt()
    }
    solve(N, A, B, C, l)
}
