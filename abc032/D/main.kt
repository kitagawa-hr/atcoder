import java.io.BufferedInputStream

// Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
fun main(args: Array<String>) {
    fun StringArray(size: Int, init: (Int) -> String = { "\u0000" }): Array<String> {
        return Array<String>(size, init)
    }
    fun iterateTokens(): Iterator<String> {
        val reader = BufferedInputStream(System.`in`).bufferedReader()
        val iterator = reader.lineSequence()
                .map { it.split(" ") }
                .reduce { left, right -> left + right }
                .iterator()
        return iterator
    }
    val tokens = iterateTokens()
    val N = tokens.next().toInt()
    val W = tokens.next().toLong()
    val v = LongArray(N)
    val w = LongArray(N)
    for (i in 0 until N) {
        v[i] = tokens.next().toLong()
        w[i] = tokens.next().toLong()
    }
    solve(N, W, v, w)
}

fun solve(N: Int, W: Long, v: LongArray, w: LongArray) {
    if (w.max()!! <= 1000) {
        solve1(N, W, v, w)
    } else if (v.max()!! <= 1000) {
        solve2(N, W, v, w)
    } else {
        solve3(N, W, v, w)
    }
    return
}

// w <= 1000
fun solve1(N: Int, W: Long, v: LongArray, w: LongArray) {
    // sum(w) <= 200*1000 ~ 10^5
    // dp[i][j] iまでを用いてsum(w) < jとなるsum(v)の最大値
    // dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
    // dp[0][0] = 0, dp[0][j!=0] = 0
    val WMAX = w.max()!!.toInt() * N
    if (W >= WMAX) {
        println(v.sum())
        return
    }
    val dp = Array<LongArray>(N) { LongArray(WMAX) }
    for (i in 1 until N) {
        for (j in 1 until WMAX) {
            dp[i][j] = maxOf(dp[i - 1][j], dp[i - 1].getOrElse(j - w[i].toInt(), { 0 }) + v[i])
        }
    }
    println(dp[N - 1][W.toInt()])
    return
}

// v <= 1000
fun solve2(N: Int, W: Long, v: LongArray, w: LongArray) {
    // sum(v) <= 200*1000 ~ 10^5
    // dp[i][j] iまでを用いてsum(v) >= jとなるsum(w)の最小値
    // dp[i][j] = min(dp[i-1]dp[j], dp[i-1]dp[j-v_i] + w_j) (j - v_i >= 0)
    val INF = 1e10.toLong()
    val VMAX = 200 * 1000
    val dp = Array<LongArray>(N) { LongArray(VMAX) }
    for (j in 1 until VMAX) { dp[0][j] = INF }
    for (i in 1 until N) {
        for (j in 1 until VMAX) {
            dp[i][j] = minOf(dp[i - 1][j], dp[i - 1].getOrElse(j - v[i].toInt(), { INF }) + w[i])
        }
    }
    println(dp[N - 1].indexOfLast { it <= W })
    return
}

// N <= 30
fun solve3(N: Int, W: Long, v: LongArray, w: LongArray) {
    // 枝刈り探索 2^15 * log(2^15) ~ 5 * 10^5
    val n = N / 2
    val A = prunePair(bitAllSearch(v.slice(0 until n), w.slice(0 until n)))
    val B = prunePair(bitAllSearch(v.slice(n until N), w.slice(n until N)))
    var ans = 0L
    for (a in A) {
        val binSearchedIndex = B.binarySearchBy(W - a.second) { it.second }
        val indexOfB = if (binSearchedIndex >= 0) binSearchedIndex else if (binSearchedIndex == -1) 0 else (-binSearchedIndex - 2)
        val value = a.first + (B.getOrNull(indexOfB)?.first ?: 0)
        ans = maxOf(ans, value)
    }
    println(ans)
    return
}

fun bitAllSearch(v: List<Long>, w: List<Long>): Array<Pair<Long, Long>> {
    val vw = Array<Pair<Long, Long>>(50000) { 0L to 0L }
    var bit = 0
    while (bit < (1 shl v.size)) {
        var vs = 0L
        var ws = 0L
        for (i in 0 until v.size) {
            if ((bit and (1 shl i)) > 0) {
                vs += v[i]
                ws += w[i]
            }
        }
        vw[bit] = vs to ws
        bit += 1
    }
    return vw
}

fun prunePair(vw: Array<Pair<Long, Long>>): List<Pair<Long, Long>> {
    val vws = vw.sortedBy { it.second }.filter { it.first != 0L }
    val pairs = mutableListOf<Pair<Long, Long>>()
    pairs.add(vws[0])
    for (i in 1 until vws.size) {
        if (vws[i].first > pairs.last().first) {
            pairs.add(vws[i])
        }
    }
    return pairs
}