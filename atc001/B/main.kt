import java.io.*
import java.util.*

const val YES = "Yes"
const val NO = "No"
var pw = PrintWriter(System.out)

class UnionFind(n: Int) {
    data class Node(var parent: Int, var size: Int)
    val nodes = Array<Node>(n) { Node(parent = it, size = 0) }
    fun findRoot(x: Int): Int {
        if (x == this.nodes[x].parent) return x
        nodes[x].parent = findRoot(nodes[x].parent)
        return nodes[x].parent
    }
    fun unite(x: Int, y: Int) {
        var xRoot = findRoot(x)
        var yRoot = findRoot(y)
        if (xRoot == yRoot) return
        if (getSize(xRoot) < getSize(yRoot)) {
            nodes[xRoot].parent = yRoot
            nodes[yRoot].size += nodes[xRoot].size
        } else {
            nodes[yRoot].parent = xRoot
            nodes[xRoot].size += nodes[yRoot].size
        }
    }
    fun getSize(x: Int) = nodes[findRoot(x)].size
    fun isSame(x: Int, y: Int) = findRoot(x) == findRoot(y)
}

// 頂点の個数, クエリの回数, P: 0のとき連結クエリ, 1のとき判定クエリ, A[i] <-> B[i]の連結
fun solve(N: Long, Q: Long, P: LongArray, A: LongArray, B: LongArray) {
    val n = N.toInt()
    val q = Q.toInt()
    val uf = UnionFind(n)
    for (i in 0 until q) {
        if (P[i] == 0L) uf.unite(A[i].toInt(), B[i].toInt())
        else {
            if (uf.isSame(A[i].toInt(), B[i].toInt())) {
                pw.println(YES)
            } else { pw.println(NO) }
        }
    }
    pw.flush()
    return
}

// Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
fun main(args: Array<String>) {
    fun StringArray(size: Int, init: (Int) -> String = { "\u0000" }): Array<String> {
        return Array<String>(size, init)
    }
    class Scanner(stream: InputStream) {
        private val reader = BufferedInputStream(stream).bufferedReader()
        private var st: StringTokenizer? = null
        fun next(): String {
            while (!(st?.hasMoreTokens() ?: false)) st = StringTokenizer(reader.readLine())
            return st!!.nextToken()
        }
    }
    val sc = Scanner(System.`in`)
    val N = sc.next().toLong()
    val Q = sc.next().toLong()
    val P = LongArray(Q.toInt())
    val A = LongArray(Q.toInt())
    val B = LongArray(Q.toInt())
    for (i in 0 until Q.toInt()) {
        P[i] = sc.next().toLong()
        A[i] = sc.next().toLong()
        B[i] = sc.next().toLong()
    }
    solve(N, Q, P, A, B)
}
